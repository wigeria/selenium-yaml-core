{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SeleniumYAML SeleniumYAML is an open-source high level framework for creating Selenium bots. It's bots are written in YAML and attempt to be as user-friendly as possible while allowing for customization and additions for more complex use cases. Features include: User-friendly YAML Bots that can be developed rapidly Modular bots to keep things DRY Template and Performance level context Support for calling APIs for importing/exporting data Examples Some examples of what can be done are available here . Quickstart To quickly get set up, start following the Quickstart tutorial here . Contribute Contributions of any kind are very welcome. To get started with contributing, refer to the [contribution page]((https://github.com/wigeria/selenium-yaml-core) in our github repo.","title":"Home"},{"location":"#seleniumyaml","text":"SeleniumYAML is an open-source high level framework for creating Selenium bots. It's bots are written in YAML and attempt to be as user-friendly as possible while allowing for customization and additions for more complex use cases. Features include: User-friendly YAML Bots that can be developed rapidly Modular bots to keep things DRY Template and Performance level context Support for calling APIs for importing/exporting data","title":"SeleniumYAML"},{"location":"#examples","text":"Some examples of what can be done are available here .","title":"Examples"},{"location":"#quickstart","text":"To quickly get set up, start following the Quickstart tutorial here .","title":"Quickstart"},{"location":"#contribute","text":"Contributions of any kind are very welcome. To get started with contributing, refer to the [contribution page]((https://github.com/wigeria/selenium-yaml-core) in our github repo.","title":"Contribute"},{"location":"quickstart/basic-usage/","text":"Basic Usage This page describes the basics of creating and running bots. Refer to this page for further details on each of the available Steps. Creating a Bot SeleniumYAML expects each automation guideline to be provided in a particular schema. Each YAML file is treated as an independent bot, and can be passed to the run_sally script to be executed. The base YAML Schema looks like this: title: Bot Title steps: List of steps Each bot should ideally have a unique title (although this is only required if you're chaining bots together using the run_bot step), and a list of steps . Step Schema Each step defined in the steps array of a Bot file must have a title and action field, and look similar to the following: title: Step Title action: Step Identifier ... other fields specific to the step identified by the action The title for each step in the steps array must be unique within that bot. This is due to the fact that each step can have it's own namespace within the performance_context (defined here ). Connecting the dots With the Bot Schema and the Step Schema combined, we can now come up with the basic schema for a bot that performs two steps. title: Bot Title steps: - title: Step 1 Title action: Step Identifier ... other fields specific to the step - title: Step 2 Title action: Another Step Identifier ... other fields specific to the step Running a Bot Bots defined in YAML Files can be run by passing them to the run_sally script. The following command would run the bot specified in the bot.yaml file: run_sally --yaml-file=bot.yaml Use the --help flag to get details on other available parameters. For examples, refer to the bots in our Github repository .","title":"Basic Usage"},{"location":"quickstart/basic-usage/#basic-usage","text":"This page describes the basics of creating and running bots. Refer to this page for further details on each of the available Steps.","title":"Basic Usage"},{"location":"quickstart/basic-usage/#creating-a-bot","text":"SeleniumYAML expects each automation guideline to be provided in a particular schema. Each YAML file is treated as an independent bot, and can be passed to the run_sally script to be executed. The base YAML Schema looks like this: title: Bot Title steps: List of steps Each bot should ideally have a unique title (although this is only required if you're chaining bots together using the run_bot step), and a list of steps .","title":"Creating a Bot"},{"location":"quickstart/basic-usage/#step-schema","text":"Each step defined in the steps array of a Bot file must have a title and action field, and look similar to the following: title: Step Title action: Step Identifier ... other fields specific to the step identified by the action The title for each step in the steps array must be unique within that bot. This is due to the fact that each step can have it's own namespace within the performance_context (defined here ).","title":"Step Schema"},{"location":"quickstart/basic-usage/#connecting-the-dots","text":"With the Bot Schema and the Step Schema combined, we can now come up with the basic schema for a bot that performs two steps. title: Bot Title steps: - title: Step 1 Title action: Step Identifier ... other fields specific to the step - title: Step 2 Title action: Another Step Identifier ... other fields specific to the step","title":"Connecting the dots"},{"location":"quickstart/basic-usage/#running-a-bot","text":"Bots defined in YAML Files can be run by passing them to the run_sally script. The following command would run the bot specified in the bot.yaml file: run_sally --yaml-file=bot.yaml Use the --help flag to get details on other available parameters. For examples, refer to the bots in our Github repository .","title":"Running a Bot"},{"location":"quickstart/customization/","text":"Customization Most of the functionality provided by SeleniumYAML can be customized and added to for suiting your own needs. This page aims to explain how to modify and add new Steps, Fields and Validators. The Structure of a Step A Step is defined as a derivative of the selenium_yaml.steps.BaseStep class. There are 3 main things that must be added to each new step. selenium_yaml.fields.Field Attributes for each field that the step needs to receive as input in the YAML structure of the step A Meta class containing a fields list that should have a list of each defined field in the step A perform function that will be responsible for performing the actual functionality of the step With that taken into account, here's what the core NavigateStep looks like: class NavigateStep(BaseStep): \"\"\" Step that performs a ``driver.get`` action with the given ``target_url`` \"\"\" url = fields.CharField(required=True) def perform(self, driver, performance_data, performance_context): \"\"\" Navigates the driver to the provided ``url`` \"\"\" driver.get(performance_data[\"url\"]) class Meta: fields = [\"url\"] Let's go over each part: url = fields.CharField(required=True) This is what is going to be used to receive the url field as input from the YAML. The CharField implements it's own set of validators, which is validated prior to the bot execution. Here's what the step might look like in the YAML: - title: Step Title action: Step Identifier // This is explained in the Step Registration section url: https://google.com Now, so that the step-parser can actually recognize the existence of that field, it must be added to the Meta class. class Meta: fields = [\"url\"] And finally, the actual performance method for the step: def perform(self, driver, performance_data, performance_context): \"\"\" Navigates the driver to the provided ``url`` \"\"\" driver.get(performance_data[\"url\"]) The performance_data variable contains the data provided to the step in the YAML rendered with the performance_context . If you would like to access the raw data as provided in the YAML, you could access it from the step_data attribute on the class (through self.step_data in the perform method). If you would like to access the data after validation, but prior to being rendered, you could access it through the validated_data property on the class. Registering a Step Before a step can be used in the YAML, it needs to be registered. This can be done through the provided class decorator: from selenium_yaml.steps.registered_steps import selenium_step @selenium_step(\"step identifier\") class NavigateStep(BaseStep): ... The Identifier passed into the selenium_step decorator is what is going to be used as the \"action\" identifier for the step in the YAML. This must be unique; using duplicates will result in an error. Custom Validators Custom validators can be created to be used in fields for providing custom validation. All validators should derive from the validators.Validator class. The validate() method can be overwritten to provide custom validation for values, and the __init__ method can be overwritten for adding new arguments. Here's an example of a RegexValidator that raises an exception if a value doesn't match the given regex: import re from selenium_yaml.validators import Validator class RegexValidator(Validator): \"\"\" Validator which checks to make sure that the given value is matches the given regex \"\"\" def __init__(self, regex, *args, **kwargs): \"\"\" Adds a ``options`` attribute to the validator prior to init \"\"\" self.regex = regex super().__init__(*args, **kwargs) def validate(self, value): \"\"\" Validates that the value matches the regex \"\"\" if not re.match(self.regex, value): raise exceptions.ValidationError( f\"The `{value}` does not match `{self.regex}`.\") In case of any validation errors, the validators should raise exceptions.ValidationError exceptions so that they can be handled correctly by the parser. Custom Fields A Field class can provide it's own methods for Validation ( validate ) and overwrite the __init__ method to add any validators. It is suggested to use validators for validation, instead of just directly validating everything in the validate method. Here's a very basic example of a field that adds a custom \"RegexValidator\" to validate phone numbers: from selenium_yaml.fields import Field class PhoneNumberField(Field): \"\"\" Field defining regex validation for phone numbers \"\"\" def __init__(self, *args, validators=None, **kwargs): \"\"\" Creates an instance of a PhoneNumberField and adds a ``RegexValidator`` validator \"\"\" validators = validators or [] validators.append(field_validators.RegexValidator(r\"\\d{3}-\\d{3}-\\d{4}\")) super().__init__(*args, validators=validators, **kwargs) These fields can then be used in Steps as required. Running the Customized Bot After all of the customization, you need to execute SeleniumYAML's engine: from selenium_yaml import SeleniumYAML # Define/Import/Register any custom steps here if __name__ == \"__main__\": engine = SeleniumYAML( yaml_file=\"path to the yaml file/a file-like object\", save_screenshots=False, # If true, a screenshot of the driver will be saved after each step template_context={}, # The template context used for rendering the YAML through Jinja parse_template=False # If true, the template_context will be used to render the YAML through Jinja ) engine.perform()","title":"Customization"},{"location":"quickstart/customization/#customization","text":"Most of the functionality provided by SeleniumYAML can be customized and added to for suiting your own needs. This page aims to explain how to modify and add new Steps, Fields and Validators.","title":"Customization"},{"location":"quickstart/customization/#the-structure-of-a-step","text":"A Step is defined as a derivative of the selenium_yaml.steps.BaseStep class. There are 3 main things that must be added to each new step. selenium_yaml.fields.Field Attributes for each field that the step needs to receive as input in the YAML structure of the step A Meta class containing a fields list that should have a list of each defined field in the step A perform function that will be responsible for performing the actual functionality of the step With that taken into account, here's what the core NavigateStep looks like: class NavigateStep(BaseStep): \"\"\" Step that performs a ``driver.get`` action with the given ``target_url`` \"\"\" url = fields.CharField(required=True) def perform(self, driver, performance_data, performance_context): \"\"\" Navigates the driver to the provided ``url`` \"\"\" driver.get(performance_data[\"url\"]) class Meta: fields = [\"url\"] Let's go over each part: url = fields.CharField(required=True) This is what is going to be used to receive the url field as input from the YAML. The CharField implements it's own set of validators, which is validated prior to the bot execution. Here's what the step might look like in the YAML: - title: Step Title action: Step Identifier // This is explained in the Step Registration section url: https://google.com Now, so that the step-parser can actually recognize the existence of that field, it must be added to the Meta class. class Meta: fields = [\"url\"] And finally, the actual performance method for the step: def perform(self, driver, performance_data, performance_context): \"\"\" Navigates the driver to the provided ``url`` \"\"\" driver.get(performance_data[\"url\"]) The performance_data variable contains the data provided to the step in the YAML rendered with the performance_context . If you would like to access the raw data as provided in the YAML, you could access it from the step_data attribute on the class (through self.step_data in the perform method). If you would like to access the data after validation, but prior to being rendered, you could access it through the validated_data property on the class.","title":"The Structure of a Step"},{"location":"quickstart/customization/#registering-a-step","text":"Before a step can be used in the YAML, it needs to be registered. This can be done through the provided class decorator: from selenium_yaml.steps.registered_steps import selenium_step @selenium_step(\"step identifier\") class NavigateStep(BaseStep): ... The Identifier passed into the selenium_step decorator is what is going to be used as the \"action\" identifier for the step in the YAML. This must be unique; using duplicates will result in an error.","title":"Registering a Step"},{"location":"quickstart/customization/#custom-validators","text":"Custom validators can be created to be used in fields for providing custom validation. All validators should derive from the validators.Validator class. The validate() method can be overwritten to provide custom validation for values, and the __init__ method can be overwritten for adding new arguments. Here's an example of a RegexValidator that raises an exception if a value doesn't match the given regex: import re from selenium_yaml.validators import Validator class RegexValidator(Validator): \"\"\" Validator which checks to make sure that the given value is matches the given regex \"\"\" def __init__(self, regex, *args, **kwargs): \"\"\" Adds a ``options`` attribute to the validator prior to init \"\"\" self.regex = regex super().__init__(*args, **kwargs) def validate(self, value): \"\"\" Validates that the value matches the regex \"\"\" if not re.match(self.regex, value): raise exceptions.ValidationError( f\"The `{value}` does not match `{self.regex}`.\") In case of any validation errors, the validators should raise exceptions.ValidationError exceptions so that they can be handled correctly by the parser.","title":"Custom Validators"},{"location":"quickstart/customization/#custom-fields","text":"A Field class can provide it's own methods for Validation ( validate ) and overwrite the __init__ method to add any validators. It is suggested to use validators for validation, instead of just directly validating everything in the validate method. Here's a very basic example of a field that adds a custom \"RegexValidator\" to validate phone numbers: from selenium_yaml.fields import Field class PhoneNumberField(Field): \"\"\" Field defining regex validation for phone numbers \"\"\" def __init__(self, *args, validators=None, **kwargs): \"\"\" Creates an instance of a PhoneNumberField and adds a ``RegexValidator`` validator \"\"\" validators = validators or [] validators.append(field_validators.RegexValidator(r\"\\d{3}-\\d{3}-\\d{4}\")) super().__init__(*args, validators=validators, **kwargs) These fields can then be used in Steps as required.","title":"Custom Fields"},{"location":"quickstart/customization/#running-the-customized-bot","text":"After all of the customization, you need to execute SeleniumYAML's engine: from selenium_yaml import SeleniumYAML # Define/Import/Register any custom steps here if __name__ == \"__main__\": engine = SeleniumYAML( yaml_file=\"path to the yaml file/a file-like object\", save_screenshots=False, # If true, a screenshot of the driver will be saved after each step template_context={}, # The template context used for rendering the YAML through Jinja parse_template=False # If true, the template_context will be used to render the YAML through Jinja ) engine.perform()","title":"Running the Customized Bot"},{"location":"quickstart/installation/","text":"Installation The bot is relatively simple to install, but you'll need to install a few core dependencies before you can use it. Installing Python 3 SeleniumYAML doesn't support Python 2, considering that it's been discontinued for quite a while now. You can confirm that you have Python 3.6+ using python --version and make sure you get an output higher than Python 3.6 . If you have 3.6 or higher, feel free to skip this. Otherwise, refer to this page to install Python 3.6 or higher. Installing PIP PIP is the most widely used package manager for Python. If you don't already have it installed (if you installed using a binary, it should've come prepackaged), refer to this page to install it. Installing Selenium and a Webdriver Selenium is the automation library used by SeleniumYAML bots (duh). Installing it is rather straight forward for most systems; simply run the following: pip install selenium If you run into any issues, refer to Selenium's installation page . Now, you need to install a Webdriver. There are a lot of these out there, but you need to install one for whichever WebBrowser you're looking to automate tasks on with SeleniumYAML. Make sure you install one that supports the version of the browser you have installed. Here's some of the popular ones. Browser: Download Link Chrome: https://sites.google.com/a/chromium.org/chromedriver/downloads Firefox: https://github.com/mozilla/geckodriver/releases Edge: https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/ Safari: https://webkit.org/blog/6900/webdriver-support-in-safari-10/ After you've downloaded the one you're interested in, it's recommended that you add it to your PATH environment variable. Instructions on doing this can vary based on your OS, so it's suggested that you do a Google search. Installing SeleniumYAML Finally done with the dependencies. Installing SeleniumYAML is simple; just run this: pip install selenium-yaml You can confirm that you've installed it successfully by running run_sally --version .","title":"Installation"},{"location":"quickstart/installation/#installation","text":"The bot is relatively simple to install, but you'll need to install a few core dependencies before you can use it.","title":"Installation"},{"location":"quickstart/installation/#installing-python-3","text":"SeleniumYAML doesn't support Python 2, considering that it's been discontinued for quite a while now. You can confirm that you have Python 3.6+ using python --version and make sure you get an output higher than Python 3.6 . If you have 3.6 or higher, feel free to skip this. Otherwise, refer to this page to install Python 3.6 or higher.","title":"Installing Python 3"},{"location":"quickstart/installation/#installing-pip","text":"PIP is the most widely used package manager for Python. If you don't already have it installed (if you installed using a binary, it should've come prepackaged), refer to this page to install it.","title":"Installing PIP"},{"location":"quickstart/installation/#installing-selenium-and-a-webdriver","text":"Selenium is the automation library used by SeleniumYAML bots (duh). Installing it is rather straight forward for most systems; simply run the following: pip install selenium If you run into any issues, refer to Selenium's installation page . Now, you need to install a Webdriver. There are a lot of these out there, but you need to install one for whichever WebBrowser you're looking to automate tasks on with SeleniumYAML. Make sure you install one that supports the version of the browser you have installed. Here's some of the popular ones. Browser: Download Link Chrome: https://sites.google.com/a/chromium.org/chromedriver/downloads Firefox: https://github.com/mozilla/geckodriver/releases Edge: https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/ Safari: https://webkit.org/blog/6900/webdriver-support-in-safari-10/ After you've downloaded the one you're interested in, it's recommended that you add it to your PATH environment variable. Instructions on doing this can vary based on your OS, so it's suggested that you do a Google search.","title":"Installing Selenium and a Webdriver"},{"location":"quickstart/installation/#installing-seleniumyaml","text":"Finally done with the dependencies. Installing SeleniumYAML is simple; just run this: pip install selenium-yaml You can confirm that you've installed it successfully by running run_sally --version .","title":"Installing SeleniumYAML"},{"location":"reference/fields/","text":"Fields This is a reference of the fields included with the library. Any custom fields can added as required by following the instructions available here . Fields are used in steps for the main purpose of providing collective validation for input to a common group of data. CharField max_length - The maximum length allowed for the input options - An array of options that the input could be allowed to be This field implements the following validators: TypeValidator(field_type=str) MaxLengthValidator if the max length is provided OptionsValidator if any options are provided IntegerField This field implements the following validators: TypeValidator(field_type=int) BooleanField This field implements the following validators: TypeValidator(field_type=bool) DictField This field implements the following validators: TypeValidator(field_type=dict) FilePathField This field implements the following validators: FilePathValidator Used to receive the path of a file in the system as input. ResolvedVariableField required_type - The type the input is allowed to be if it isn't a resolved variable This field implements the following validators: ResolvedVariableValidator NestedStepsField This field implements the following validators individuallly for each element in the input: StepValidator A rather specific step that is used for parsing and validating sub-steps.","title":"Fields"},{"location":"reference/fields/#fields","text":"This is a reference of the fields included with the library. Any custom fields can added as required by following the instructions available here . Fields are used in steps for the main purpose of providing collective validation for input to a common group of data.","title":"Fields"},{"location":"reference/fields/#charfield","text":"max_length - The maximum length allowed for the input options - An array of options that the input could be allowed to be This field implements the following validators: TypeValidator(field_type=str) MaxLengthValidator if the max length is provided OptionsValidator if any options are provided","title":"CharField"},{"location":"reference/fields/#integerfield","text":"This field implements the following validators: TypeValidator(field_type=int)","title":"IntegerField"},{"location":"reference/fields/#booleanfield","text":"This field implements the following validators: TypeValidator(field_type=bool)","title":"BooleanField"},{"location":"reference/fields/#dictfield","text":"This field implements the following validators: TypeValidator(field_type=dict)","title":"DictField"},{"location":"reference/fields/#filepathfield","text":"This field implements the following validators: FilePathValidator Used to receive the path of a file in the system as input.","title":"FilePathField"},{"location":"reference/fields/#resolvedvariablefield","text":"required_type - The type the input is allowed to be if it isn't a resolved variable This field implements the following validators: ResolvedVariableValidator","title":"ResolvedVariableField"},{"location":"reference/fields/#nestedstepsfield","text":"This field implements the following validators individuallly for each element in the input: StepValidator A rather specific step that is used for parsing and validating sub-steps.","title":"NestedStepsField"},{"location":"reference/resolved-variables/","text":"Resolved Variables Resolved Variables are template variables that can be added to steps in bots that are rendered right before the execution of the step using all of the context stored prior to it's execution. Note that these variables are not rendered in the title and action fields for the steps, since those are used prior to the actual execution. All of the data returned by a Step's perform() method (note that this should always be None or a Dict) is stored in the performance context under that Step's Namespace (it's title ). Resolved Variables allow for nested access using double underscores ( __ ). Schema Resolved Variables can be added to the bots using by enclosing variables in ${...} brackets. Spaces are allowed inside the brackets, as well as certain functions defined here Accessing Nested Fields Context data can be nested infinitely and can be accessed by passing through levels using __ . For example, if we had a CallAPIStep step titled Call an API (which stores the response body in the context variable) which received a JSON response of {key1: {key2: value}} , we could access value using the following in any of the following steps: ${Call an API__content__key1__key2} If we received a response of {key1: [value1, value2, value3]} however, and we wanted to access value3 , we could retreive that through it's zero-index as follows: ${Call an API__content__key1__2} These two formats can be used as required to traverse through dictionaries and lists. Using Functions Certain functions can be used for modifying resolved variables for more complex use cases. The functions available depend on the type of variable they're being used against. These can be used through the | (pipe) symbol. For example, if we wanted to us the split function to separate a string by , and get the first value, we could do the following: ${Step Title__string_variable|split(',')__0} Strings split(delim, maxsplit=None) - Splits the string by the given delimiter. upper() - Uppercases the entire string lower() - Lowercasess the entire string capitalize() - Capitalizes the first letter of the string zfill(width) - Adds zeroes before the string so that it reaches the required width strip() - Strips spaces from before and after the string len() - Gives back the length of the string as an integer startswith(prefix) - Returns a boolean based on whether a string starts with a value or not endswith(prefix) - Returns a boolean based on whether a string ends with a value or not List len() - Returns the length of the string as an integer index(value) - Returns the index of the given value in the list reverse() - Returns the list in reverse sort() - Returns the sorted list join(delim) - Returns the list joined by the delimiter as a string Dict get(key, default=None) - Returns the key if it exists in the dict, otherwise returns the default if provided keys() - Returns a list of all keys in the dictionary items() - Returns a list of tuples of all (key, value) pairs in the dictionary","title":"Resolved Variables"},{"location":"reference/resolved-variables/#resolved-variables","text":"Resolved Variables are template variables that can be added to steps in bots that are rendered right before the execution of the step using all of the context stored prior to it's execution. Note that these variables are not rendered in the title and action fields for the steps, since those are used prior to the actual execution. All of the data returned by a Step's perform() method (note that this should always be None or a Dict) is stored in the performance context under that Step's Namespace (it's title ). Resolved Variables allow for nested access using double underscores ( __ ).","title":"Resolved Variables"},{"location":"reference/resolved-variables/#schema","text":"Resolved Variables can be added to the bots using by enclosing variables in ${...} brackets. Spaces are allowed inside the brackets, as well as certain functions defined here","title":"Schema"},{"location":"reference/resolved-variables/#accessing-nested-fields","text":"Context data can be nested infinitely and can be accessed by passing through levels using __ . For example, if we had a CallAPIStep step titled Call an API (which stores the response body in the context variable) which received a JSON response of {key1: {key2: value}} , we could access value using the following in any of the following steps: ${Call an API__content__key1__key2} If we received a response of {key1: [value1, value2, value3]} however, and we wanted to access value3 , we could retreive that through it's zero-index as follows: ${Call an API__content__key1__2} These two formats can be used as required to traverse through dictionaries and lists.","title":"Accessing Nested Fields"},{"location":"reference/resolved-variables/#using-functions","text":"Certain functions can be used for modifying resolved variables for more complex use cases. The functions available depend on the type of variable they're being used against. These can be used through the | (pipe) symbol. For example, if we wanted to us the split function to separate a string by , and get the first value, we could do the following: ${Step Title__string_variable|split(',')__0}","title":"Using Functions"},{"location":"reference/resolved-variables/#strings","text":"split(delim, maxsplit=None) - Splits the string by the given delimiter. upper() - Uppercases the entire string lower() - Lowercasess the entire string capitalize() - Capitalizes the first letter of the string zfill(width) - Adds zeroes before the string so that it reaches the required width strip() - Strips spaces from before and after the string len() - Gives back the length of the string as an integer startswith(prefix) - Returns a boolean based on whether a string starts with a value or not endswith(prefix) - Returns a boolean based on whether a string ends with a value or not","title":"Strings"},{"location":"reference/resolved-variables/#list","text":"len() - Returns the length of the string as an integer index(value) - Returns the index of the given value in the list reverse() - Returns the list in reverse sort() - Returns the sorted list join(delim) - Returns the list joined by the delimiter as a string","title":"List"},{"location":"reference/resolved-variables/#dict","text":"get(key, default=None) - Returns the key if it exists in the dict, otherwise returns the default if provided keys() - Returns a list of all keys in the dictionary items() - Returns a list of tuples of all (key, value) pairs in the dictionary","title":"Dict"},{"location":"reference/steps/","text":"Steps This is a reference for the steps included with the library. For details on creating your own custom steps, refer to this page . Notes: - Details about Resolved Variables mentioned herein can be found here - The fields that are required are highlighted in bold Base Fields All steps must have the following two fields in the YAML, so that they can be identified and validated by the parser. title The title field is used as a unique namespace for a step within a bot. This name is used for storing and accessing performance_context for the step as well as for a few other tasks that require namespacing such as screenshots, passing back validation errors, etc. action This field is used to identify the class of the Step that needs to be performed. Each of the core steps have their own identifier that they're registered using, and any custom steps must also be registered with their own unique identifier through the selenium_yaml.steps.registered_steps.selenium_step decorator as described here . Core Steps NavigateStep - title: Navigate to URL action: navigate url: <URL to navigate to> url - CharField for the URL that the driver should be navigated to This step performs a driver.get action with the provided URL. WaitStep - title: Wait for a fixed amount of time action: wait seconds: <Seconds to wait for> seconds - IntegerField for the number of steps to wait for This step performs a wait for the given number of seconds using time.sleep() . WaitForElementStep - title: Wait for the element to be clickable action: wait_for_element element: <Xpath selector for the element> seconds: <Seconds to wait for> element - CharField for the XPath selector for the element to wait for seconds - IntegerField for the number of seconds to wait for This step performs waits for the presence of the given element for the given number of seconds . ClickElementStep - title: Click on an element action: click element: <Xpath Selector for the Element> element - CharField for the XPath selector for the element to click on This step clicks on the element identified by the XPath using driver.click() . TypeTextStep - title: Type text into an element action: type element: <Xpath Selector for the Element> text: Text to type into the element clear: True|False element - CharField for the XPath selector for the element to send text to text - CharField for the text to send to the element clear - BooleanField ; if True, clears the field prior to sending any text This step sends the given text to the given element using driver.send_keys() . SelectOptionStep - title: Select an option from a `select` element action: select element: <Xpath selector for the Select element> option: <Value of the option that should be selected> element - CharField for the XPath selector for the select element option - CharField for the value of the option in the select element that should be selected This step selects the given option in the given select element . RunBotStep - title: Run another bot with it's file path action: run_bot path: /path/to/the/bot save_screenshots: True|False parse_template: True|False template_context: - Key: Value path - FilePathField to the path of the both that should be run save_screenshots - BooleanField for whether this bot should have screenshots' saved or not parse_template - BooleanField ; if True, the template_context field will be used for rendering the Bot's YAML as a Jinja Template prior to execution template_context - ResolvedVariableField(required_type=dict) field that can either be a resolved variable or a dictionary, and will be used for rendering the Bot's YAML if parse_template is True This step is used for running another bot with the current performance context available in the bot. CallAPIStep - title: Call an API and store it's response and status code action: make_request method: GET url: https://url-to-request.com/?queryParams=value body: Key: Value headers: Key: Value url - CharField for the URL that should be requested method - CharField(options=[\"GET\", \"PUT\", \"POST\"]) for the request method that should be used body - DictField for the request body headers - DictField for the request headers This step is used for sending a request with the given details and storing the response's body in the context and status_code performance context variables under the step's namespace IteratorStep - title: Iterate over an array (resolved/directly provided) action: iterate_over iterator: - Array steps: - title: Array of steps (step-1) action: navigate url: navigate-url ... iterator - ResolvedVariableField(required_type=list) field for the array to iterate over steps - NestedStepsField containing an array of steps that should be performed for each element in the iterator This step is used to perform all of the steps in the steps array for each element in the iterator . The context for each iteration is stored under the step_title__iter_index__sub_step_title namespace. The iterator could also be a resolved variable if required. In the steps in the iterator, a performance context variable for the current element being iterated over is available at ${current_iterator} . ConditionalStep - title: Conditionally run a step action: conditional value: Value to be checked equals: This is what `value` needs to equal negate: True|False steps: - title: Array of steps (step-1) action: navigate url: navigate-url ... value - CharField that can be an XPath selector to a value ( not an element ), or a string, or a resolved variable of any other type equals - CharField that the value is check against negate - BooleanField ; if True, the value must equal equals for the condition to pass - otherwise, the value must not equal equals for the condition to pass steps - NestedStepsField containing an array of steps that should be performed if the condition passes This step is used for conditionally running a set of steps. StoreXpathStep - title: Store the result of a given xpath selector in the performance context action: store_xpath selector: \"//xpath/selector/@attribute\" variable: Variable To Store Result In select_first: True|False selector - CharField for the selector to the attribute/prop that should be stored variable - CharField for the variable name that the selector 's result will be stored in under the step's namespace select_first - BooleanField ; if True, will store only the first match for the selector - otherwise, stores all of the matches in the variable as an array This step is used for storing something in the page in the performance context for later use. StorePageUrlStep - title: Store the current page's URL in a <Step Title>__url variable for later use action: store_page_url This step is used for storing the current page URL in a url variable under the step's namespace.","title":"Steps"},{"location":"reference/steps/#steps","text":"This is a reference for the steps included with the library. For details on creating your own custom steps, refer to this page . Notes: - Details about Resolved Variables mentioned herein can be found here - The fields that are required are highlighted in bold","title":"Steps"},{"location":"reference/steps/#base-fields","text":"All steps must have the following two fields in the YAML, so that they can be identified and validated by the parser. title The title field is used as a unique namespace for a step within a bot. This name is used for storing and accessing performance_context for the step as well as for a few other tasks that require namespacing such as screenshots, passing back validation errors, etc. action This field is used to identify the class of the Step that needs to be performed. Each of the core steps have their own identifier that they're registered using, and any custom steps must also be registered with their own unique identifier through the selenium_yaml.steps.registered_steps.selenium_step decorator as described here .","title":"Base Fields"},{"location":"reference/steps/#core-steps","text":"","title":"Core Steps"},{"location":"reference/steps/#navigatestep","text":"- title: Navigate to URL action: navigate url: <URL to navigate to> url - CharField for the URL that the driver should be navigated to This step performs a driver.get action with the provided URL.","title":"NavigateStep"},{"location":"reference/steps/#waitstep","text":"- title: Wait for a fixed amount of time action: wait seconds: <Seconds to wait for> seconds - IntegerField for the number of steps to wait for This step performs a wait for the given number of seconds using time.sleep() .","title":"WaitStep"},{"location":"reference/steps/#waitforelementstep","text":"- title: Wait for the element to be clickable action: wait_for_element element: <Xpath selector for the element> seconds: <Seconds to wait for> element - CharField for the XPath selector for the element to wait for seconds - IntegerField for the number of seconds to wait for This step performs waits for the presence of the given element for the given number of seconds .","title":"WaitForElementStep"},{"location":"reference/steps/#clickelementstep","text":"- title: Click on an element action: click element: <Xpath Selector for the Element> element - CharField for the XPath selector for the element to click on This step clicks on the element identified by the XPath using driver.click() .","title":"ClickElementStep"},{"location":"reference/steps/#typetextstep","text":"- title: Type text into an element action: type element: <Xpath Selector for the Element> text: Text to type into the element clear: True|False element - CharField for the XPath selector for the element to send text to text - CharField for the text to send to the element clear - BooleanField ; if True, clears the field prior to sending any text This step sends the given text to the given element using driver.send_keys() .","title":"TypeTextStep"},{"location":"reference/steps/#selectoptionstep","text":"- title: Select an option from a `select` element action: select element: <Xpath selector for the Select element> option: <Value of the option that should be selected> element - CharField for the XPath selector for the select element option - CharField for the value of the option in the select element that should be selected This step selects the given option in the given select element .","title":"SelectOptionStep"},{"location":"reference/steps/#runbotstep","text":"- title: Run another bot with it's file path action: run_bot path: /path/to/the/bot save_screenshots: True|False parse_template: True|False template_context: - Key: Value path - FilePathField to the path of the both that should be run save_screenshots - BooleanField for whether this bot should have screenshots' saved or not parse_template - BooleanField ; if True, the template_context field will be used for rendering the Bot's YAML as a Jinja Template prior to execution template_context - ResolvedVariableField(required_type=dict) field that can either be a resolved variable or a dictionary, and will be used for rendering the Bot's YAML if parse_template is True This step is used for running another bot with the current performance context available in the bot.","title":"RunBotStep"},{"location":"reference/steps/#callapistep","text":"- title: Call an API and store it's response and status code action: make_request method: GET url: https://url-to-request.com/?queryParams=value body: Key: Value headers: Key: Value url - CharField for the URL that should be requested method - CharField(options=[\"GET\", \"PUT\", \"POST\"]) for the request method that should be used body - DictField for the request body headers - DictField for the request headers This step is used for sending a request with the given details and storing the response's body in the context and status_code performance context variables under the step's namespace","title":"CallAPIStep"},{"location":"reference/steps/#iteratorstep","text":"- title: Iterate over an array (resolved/directly provided) action: iterate_over iterator: - Array steps: - title: Array of steps (step-1) action: navigate url: navigate-url ... iterator - ResolvedVariableField(required_type=list) field for the array to iterate over steps - NestedStepsField containing an array of steps that should be performed for each element in the iterator This step is used to perform all of the steps in the steps array for each element in the iterator . The context for each iteration is stored under the step_title__iter_index__sub_step_title namespace. The iterator could also be a resolved variable if required. In the steps in the iterator, a performance context variable for the current element being iterated over is available at ${current_iterator} .","title":"IteratorStep"},{"location":"reference/steps/#conditionalstep","text":"- title: Conditionally run a step action: conditional value: Value to be checked equals: This is what `value` needs to equal negate: True|False steps: - title: Array of steps (step-1) action: navigate url: navigate-url ... value - CharField that can be an XPath selector to a value ( not an element ), or a string, or a resolved variable of any other type equals - CharField that the value is check against negate - BooleanField ; if True, the value must equal equals for the condition to pass - otherwise, the value must not equal equals for the condition to pass steps - NestedStepsField containing an array of steps that should be performed if the condition passes This step is used for conditionally running a set of steps.","title":"ConditionalStep"},{"location":"reference/steps/#storexpathstep","text":"- title: Store the result of a given xpath selector in the performance context action: store_xpath selector: \"//xpath/selector/@attribute\" variable: Variable To Store Result In select_first: True|False selector - CharField for the selector to the attribute/prop that should be stored variable - CharField for the variable name that the selector 's result will be stored in under the step's namespace select_first - BooleanField ; if True, will store only the first match for the selector - otherwise, stores all of the matches in the variable as an array This step is used for storing something in the page in the performance context for later use.","title":"StoreXpathStep"},{"location":"reference/steps/#storepageurlstep","text":"- title: Store the current page's URL in a <Step Title>__url variable for later use action: store_page_url This step is used for storing the current page URL in a url variable under the step's namespace.","title":"StorePageUrlStep"},{"location":"reference/validators/","text":"Validators This is a reference for all of the base validators included with the library. Any custom validators can be added as required by following the instructions mentioned here . Validators are used in the Fields for validating the data used in the bots. RequiredValidator Validates that the given value isn't Null. Generally used to make sure that the field either has a default set or has a value passed into the step. MaxLengthValidator length - Maximum length allowed for the value Validates that the given value doesn't exceed the provided length, and that the value HAS a length in the first place. TypeValidator field_type - The type the value must be of Validates that the given value is an instance of the given field_type . OptionsValidator options - A list of the options that the value must be a part of Validates that the given value matches one of the options in the options array. FilePathValidator Validates that the given value is a path to an existing file on the system. ResolvedVariableValidator required_type - The type the value must be of if it isn't a resolved variable Validates that the variable is either a correctly formatted resolved variable, or that it matches the given required_type . Note that this doesn't validate if the resolved variable is going to be in the context during the step's execution since the validation is done prior to any execution.","title":"Validators"},{"location":"reference/validators/#validators","text":"This is a reference for all of the base validators included with the library. Any custom validators can be added as required by following the instructions mentioned here . Validators are used in the Fields for validating the data used in the bots.","title":"Validators"},{"location":"reference/validators/#requiredvalidator","text":"Validates that the given value isn't Null. Generally used to make sure that the field either has a default set or has a value passed into the step.","title":"RequiredValidator"},{"location":"reference/validators/#maxlengthvalidator","text":"length - Maximum length allowed for the value Validates that the given value doesn't exceed the provided length, and that the value HAS a length in the first place.","title":"MaxLengthValidator"},{"location":"reference/validators/#typevalidator","text":"field_type - The type the value must be of Validates that the given value is an instance of the given field_type .","title":"TypeValidator"},{"location":"reference/validators/#optionsvalidator","text":"options - A list of the options that the value must be a part of Validates that the given value matches one of the options in the options array.","title":"OptionsValidator"},{"location":"reference/validators/#filepathvalidator","text":"Validates that the given value is a path to an existing file on the system.","title":"FilePathValidator"},{"location":"reference/validators/#resolvedvariablevalidator","text":"required_type - The type the value must be of if it isn't a resolved variable Validates that the variable is either a correctly formatted resolved variable, or that it matches the given required_type . Note that this doesn't validate if the resolved variable is going to be in the context during the step's execution since the validation is done prior to any execution.","title":"ResolvedVariableValidator"}]}